#import <XCTest/XCTest.h>
#import "omc_popen.h"
#import <unistd.h>
#import <fcntl.h>

@interface OMCPopenTests : XCTestCase
@end

@implementation OMCPopenTests

// MARK: - Basic Functionality Tests

- (void)testSimpleCommandRead {
    ChildProcessInfo info;
    int result = omc_popen("echo 'Hello World'", NULL, NULL, kOMCPopenRead, &info);
    
    XCTAssertEqual(result, 0, @"omc_popen should succeed");
    XCTAssertNotEqual(info.pid, 0, @"Should have valid PID");
    XCTAssertNotEqual(info.outputFD, -1, @"Should have valid output FD");
    XCTAssertEqual(info.inputFD, -1, @"Should not have input FD in read-only mode");
    
    char buffer[256] = {0};
    ssize_t bytesRead = read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertGreaterThan(bytesRead, 0, @"Should read data");
    XCTAssertEqualObjects(@(buffer), @"Hello World\n", @"Output should match");
    
    int status = omc_pclose(info.pid);
    XCTAssertNotEqual(status, -1, @"omc_pclose should succeed");
}

- (void)testSimpleCommandWrite {
    ChildProcessInfo info;
    int result = omc_popen("cat", NULL, NULL, kOMCPopenWrite, &info);
    
    XCTAssertEqual(result, 0, @"omc_popen should succeed");
    XCTAssertNotEqual(info.inputFD, -1, @"Should have valid input FD");
    XCTAssertEqual(info.outputFD, -1, @"Should not have output FD in write-only mode");
    
    const char *testData = "Test input\n";
    write(info.inputFD, testData, strlen(testData));
    close(info.inputFD);
    
    int status = omc_pclose(info.pid);
    XCTAssertNotEqual(status, -1, @"omc_pclose should succeed");
}

- (void)testBidirectionalCommunication {
    ChildProcessInfo info;
    int result = omc_popen("tr 'a-z' 'A-Z'", NULL, NULL, 
                           kOMCPopenRead | kOMCPopenWrite, &info);
    
    XCTAssertEqual(result, 0, @"omc_popen should succeed");
    XCTAssertNotEqual(info.inputFD, -1, @"Should have input FD");
    XCTAssertNotEqual(info.outputFD, -1, @"Should have output FD");
    
    const char *input = "hello\n";
    write(info.inputFD, input, strlen(input));
    close(info.inputFD); // Close write end to signal EOF
    
    char buffer[256] = {0};
    ssize_t bytesRead = read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertGreaterThan(bytesRead, 0, @"Should read transformed data");
    XCTAssertEqualObjects(@(buffer), @"HELLO\n", @"Should be uppercase");
    
    omc_pclose(info.pid);
}

// MARK: - Custom Shell Tests

- (void)testCustomShell {
    char *customShell[] = {"/bin/sh", "-c", NULL};
    ChildProcessInfo info;
    
    int result = omc_popen("echo 'Custom Shell'", customShell, NULL, kOMCPopenRead, &info);
    XCTAssertEqual(result, 0, @"Should work with custom shell");
    
    char buffer[256] = {0};
    read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertTrue(strstr(buffer, "Custom Shell") != NULL, @"Output should contain expected text");
    
    omc_pclose(info.pid);
}

- (void)testCustomShellWithExtraArgs {
    // Test shell with additional arguments
    char *customShell[] = {"/bin/bash", "-x", "-c", NULL};
    ChildProcessInfo info;
    
    int result = omc_popen("echo 'test'", customShell, NULL, kOMCPopenRead, &info);
    XCTAssertEqual(result, 0, @"Should work with bash and -x flag");
    
    omc_pclose(info.pid);
}

// MARK: - Environment Tests

- (void)testCustomEnvironment {
    char *keys[] = {"TEST_VAR", "ANOTHER_VAR"};
    char *values[] = {"test_value", "another_value"};
    char **environ = CreateEnviron(keys, values, 2);
    
    XCTAssertNotEqual(environ, (char **)NULL, @"CreateEnviron should return valid array");
    
    ChildProcessInfo info;
    int result = omc_popen("env | grep TEST_VAR", NULL, environ, kOMCPopenRead, &info);
    XCTAssertEqual(result, 0, @"Should succeed");
    
    char buffer[512] = {0};
    read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertTrue(strstr(buffer, "TEST_VAR=test_value") != NULL, 
                  @"Environment variable should be set");
    
    omc_pclose(info.pid);
    ReleaseEnviron(environ);
}

- (void)testEnvironmentOverride {
    // Verify new values override old ones with same key
    char *keys[] = {"PATH"};
    char *values[] = {"/custom/path"};
    char **environ = CreateEnviron(keys, values, 1);
    
    ChildProcessInfo info;
    __unused int result = omc_popen("echo $PATH", NULL, environ, kOMCPopenRead, &info);
    
    char buffer[512] = {0};
    read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertEqualObjects(@(buffer), @"/custom/path\n", @"PATH should be overridden");
    
    omc_pclose(info.pid);
    ReleaseEnviron(environ);
}

- (void)testEmptyEnvironment {
    char **emptyEnv = CreateEnviron(NULL, NULL, 0);
    XCTAssertNotEqual(emptyEnv, (char **)NULL, @"Should handle empty environment");
    
    // Verify it has parent's environment copied
    int count = 0;
    while (emptyEnv[count] != NULL) count++;
    XCTAssertGreaterThan(count, 0, @"Should inherit parent environment");
    
    ReleaseEnviron(emptyEnv);
}

// MARK: - Multiple Process Tests

- (void)testMultipleConcurrentProcesses {
    ChildProcessInfo infos[5];
    
    // Launch 5 processes
    for (int i = 0; i < 5; i++) {
        char cmd[64];
        snprintf(cmd, sizeof(cmd), "echo 'Process %d'", i);
        int result = omc_popen(cmd, NULL, NULL, kOMCPopenRead, &infos[i]);
        XCTAssertEqual(result, 0, @"Process %d should launch", i);
    }
    
    // Read from all
    for (int i = 0; i < 5; i++) {
        char buffer[256] = {0};
        ssize_t bytesRead = 0;
        ssize_t totalRead = 0;
        
        // Read until we get data or EOF - handles timing without select
        while (totalRead == 0) {
            bytesRead = read(infos[i].outputFD, buffer + totalRead, sizeof(buffer) - 1 - totalRead);
            if (bytesRead > 0) {
                totalRead += bytesRead;
            } else if (bytesRead == 0) {
                // EOF - process finished
                break;
            } else if (errno != EINTR) {
                // Real error
                break;
            }
            // EINTR - retry
        }
        
        XCTAssertGreaterThan(totalRead, 0, @"Process %d should have output", i);
        if (totalRead > 0) {
            buffer[totalRead] = '\0';
            XCTAssertTrue(strlen(buffer) > 0, @"Process %d should have non-empty output", i);
        }
    }
    
    // Close all
    for (int i = 0; i < 5; i++) {
        omc_pclose(infos[i].pid);
    }
}

- (void)testProcessIsolation {
    // Ensure file descriptors don't leak between processes
    ChildProcessInfo info1, info2;
    
    omc_popen("sleep 0.1", NULL, NULL, kOMCPopenRead, &info1);
    omc_popen("sleep 0.1", NULL, NULL, kOMCPopenRead, &info2);
    
    XCTAssertNotEqual(info1.outputFD, info2.outputFD, @"FDs should be different");
    XCTAssertNotEqual(info1.pid, info2.pid, @"PIDs should be different");
    
    omc_pclose(info1.pid);
    omc_pclose(info2.pid);
}

// MARK: - Half-Close Tests

- (void)testHalfClose {
    ChildProcessInfo info;
    omc_popen("cat", NULL, NULL, kOMCPopenRead | kOMCPopenWrite, &info);
    
    write(info.inputFD, "test\n", 5);
    
    // Half-close write side
    omc_pclose_write(info.pid);
    
    // Should still be able to read
    char buffer[256] = {0};
    ssize_t bytesRead = read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertGreaterThan(bytesRead, 0, @"Should still read after half-close");
    
    omc_pclose(info.pid);
}

// MARK: - Error Handling Tests

- (void)testInvalidCommand {
    ChildProcessInfo info;
    int result = omc_popen("/nonexistent/command", NULL, NULL, kOMCPopenRead, &info);
    
    // Command will spawn but fail in exec - should still return 0 from omc_popen
    // The failure will be detected in exit status from omc_pclose
    if (result == 0) {
        int status = omc_pclose(info.pid);
        int exitCode = WEXITSTATUS(status);
        XCTAssertEqual(exitCode, 127, @"Should exit with 127 for command not found");
    }
}

- (void)testNullCommandParameter {
    ChildProcessInfo info;
    int result = omc_popen(NULL, NULL, NULL, kOMCPopenRead, &info);
    XCTAssertEqual(result, -1, @"Should fail with NULL command");
}

- (void)testNullOutputParameter {
    int result = omc_popen("echo test", NULL, NULL, kOMCPopenRead, NULL);
    XCTAssertEqual(result, -1, @"Should fail with NULL output parameter");
}

- (void)testInvalidPidInClose {
    int result = omc_pclose(99999);
    XCTAssertEqual(result, -1, @"Should fail with invalid PID");
}

- (void)testDoubleClose {
    ChildProcessInfo info;
    omc_popen("echo test", NULL, NULL, kOMCPopenRead, &info);
    
    int status1 = omc_pclose(info.pid);
    XCTAssertNotEqual(status1, -1, @"First close should succeed");
    
    int status2 = omc_pclose(info.pid);
    XCTAssertEqual(status2, -1, @"Second close should fail");
}

// MARK: - Long-Running Process Tests

- (void)testLongRunningProcess {
    ChildProcessInfo info;
    omc_popen("sleep 2 && echo 'done'", NULL, NULL, kOMCPopenRead, &info);
    
    // Should be able to wait and read
    char buffer[256] = {0};
    ssize_t bytesRead = read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertGreaterThan(bytesRead, 0, @"Should eventually read output");
    XCTAssertEqualObjects(@(buffer), @"done\n", @"Output should be correct");
    
    omc_pclose(info.pid);
}

// MARK: - Exit Status Tests

- (void)testSuccessfulExitStatus {
    ChildProcessInfo info;
    omc_popen("exit 0", NULL, NULL, kOMCPopenRead, &info);
    
    int status = omc_pclose(info.pid);
    XCTAssertNotEqual(status, -1, @"pclose should succeed");
    XCTAssertEqual(WEXITSTATUS(status), 0, @"Exit code should be 0");
}

- (void)testFailureExitStatus {
    ChildProcessInfo info;
    omc_popen("exit 42", NULL, NULL, kOMCPopenRead, &info);
    
    int status = omc_pclose(info.pid);
    XCTAssertNotEqual(status, -1, @"pclose should succeed");
    XCTAssertEqual(WEXITSTATUS(status), 42, @"Exit code should be 42");
}

// MARK: - Large Data Tests

- (void)testLargeDataTransfer {
    ChildProcessInfo info;
    omc_popen("cat", NULL, NULL, kOMCPopenRead | kOMCPopenWrite, &info);
    
    // Write 100KB of data
    const size_t dataSize = 100 * 1024;
    char *largeData = malloc(dataSize);
    memset(largeData, 'A', dataSize);
    
    ssize_t written = write(info.inputFD, largeData, dataSize);
    XCTAssertEqual(written, dataSize, @"Should write all data");
    close(info.inputFD);
    
    // Read it back
    size_t totalRead = 0;
    char *readBuffer = malloc(dataSize);
    while (totalRead < dataSize) {
        ssize_t n = read(info.outputFD, readBuffer + totalRead, dataSize - totalRead);
        if (n <= 0) break;
        totalRead += n;
    }
    
    XCTAssertEqual(totalRead, dataSize, @"Should read all data back");
    XCTAssertEqual(memcmp(largeData, readBuffer, dataSize), 0, @"Data should match");
    
    free(largeData);
    free(readBuffer);
    omc_pclose(info.pid);
}

// MARK: - Process Group Tests

- (void)testProcessGroupCreation {
    ChildProcessInfo info;
    // Use command that reports its own PGID to avoid race condition
    omc_popen("/bin/ps -o pgid= -p $$", NULL, NULL, kOMCPopenRead, &info);
    
    char buffer[256] = {0};
    ssize_t bytesRead = read(info.outputFD, buffer, sizeof(buffer) - 1);
    XCTAssertGreaterThan(bytesRead, 0, @"Should read PGID");
    
    // Parse the PGID from output
    pid_t reported_pgid = (pid_t)atoi(buffer);
    
    // Child should report its own PID as its PGID (since setpgid(0,0) was called)
    XCTAssertEqual(reported_pgid, info.pid,
                   @"Process should be in process group matching its PID");
    
    omc_pclose(info.pid);
}

@end
